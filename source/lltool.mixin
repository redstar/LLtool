
void parseLltool() {
    if (tok.kind.among(TokenKind.PercentPercent, TokenKind.Percenteoi, TokenKind.Percentstart, TokenKind.Percenttoken)) {
        parseHeader();
    }
    do {
        parseRule();
    } while (tok.kind == TokenKind.Identifier);
    return;
_error:
    while (tok.kind != TokenKind._eoi && tok.kind != TokenKind._eoi)
        advance();
}

void parseHeader() {
    while (tok.kind.among(TokenKind.Percenteoi, TokenKind.Percentstart, TokenKind.Percenttoken)) {
        if (tok.kind == TokenKind.Percentstart) {
            advance();
            if (expect(TokenKind.Identifier))
                goto _error;
            builder.startSymbol(tok.pos, tok.val);
            advance();
        }
        else if (tok.kind == TokenKind.Percenttoken) {
            advance();
            parseTokenlist();
        }
        else if (tok.kind == TokenKind.Percenteoi) {
            advance();
            if (expect(TokenKind.Identifier))
                goto _error;
            builder.eoiSymbol(tok.pos, tok.val);
            advance();
        }
    }
    if (consume(TokenKind.PercentPercent))
        goto _error;
    return;
_error:
    while (tok.kind != TokenKind._eoi && tok.kind != TokenKind.Identifier)
        advance();
}

void parseTokenlist() {
    parseTokendecl();
    while (tok.kind == TokenKind.Comma) {
        advance();
        parseTokendecl();
    }
    return;
_error:
    while (tok.kind != TokenKind._eoi && tok.kind != TokenKind.PercentPercent)
        advance();
}

void parseTokendecl() {
    size_t pos; string val, ext;
    if (tok.kind == TokenKind.Identifier) {
        pos = tok.pos; val = tok.val;
        advance();
    }
    else if (tok.kind == TokenKind.String) {
        pos = tok.pos; val = tok.val;
        advance();
    }
    if (tok.kind == TokenKind.Equal) {
        advance();
        if (expect(TokenKind.Identifier))
            goto _error;
        ext = tok.val;
        advance();
    }
    builder.terminal(pos, val, ext);
    return;
_error:
    while (tok.kind != TokenKind._eoi && !tok.kind.among(TokenKind.PercentPercent, TokenKind.Comma))
        advance();
}

void parseRule() {
    Node node;
    parseNonterminal(node);
    if (consume(TokenKind.Colon))
        goto _error;
    parseRhs(node.link);
    node.link.back = node;
    if (consume(TokenKind.Semi))
        goto _error;
    return;
_error:
    while (tok.kind != TokenKind._eoi && !tok.kind.among(TokenKind._eoi, TokenKind.Identifier))
        advance();
}

void parseNonterminal(out Node node) {
    if (expect(TokenKind.Identifier))
        goto _error;
    node = builder.nonterminal(tok.pos, tok.val);
    advance();
    if (tok.kind == TokenKind.Argument) {
        node.formalArgs = tok.val;
        advance();
    }
    if (tok.kind == TokenKind.Code) {
        advance();
    }
    return;
_error:
    while (tok.kind != TokenKind._eoi && tok.kind != TokenKind.Colon)
        advance();
}

void parseRhs(out Node node) {
    parseSequence(node);
    if (tok.kind == TokenKind.Pipe) {
        node = builder.alternative(node.pos, node);
                                           auto alt = node.link; alt.back = node;
        do {
            if (consume(TokenKind.Pipe))
                goto _error;
            parseSequence(alt.link);
            alt = alt.link; alt.back = node;
        } while (tok.kind == TokenKind.Pipe);
    }
    return;
_error:
    while (tok.kind != TokenKind._eoi && !tok.kind.among(TokenKind.RightParenthesis, TokenKind.RightParenthesisStar, TokenKind.RightParenthesisPlus, TokenKind.RightParenthesisQuestion, TokenKind.Semi))
        advance();
}

void parseSequence(out Node node) {
    Node last; node = builder.sequence(tok.pos);
    while (tok.kind.among(TokenKind.Percentif, TokenKind.LeftParenthesis, TokenKind.Code, TokenKind.Identifier, TokenKind.String)) {
        Node n;
        if (tok.kind == TokenKind.LeftParenthesis) {
            parseGroup(n);
        }
        else if (tok.kind == TokenKind.Identifier) {
            n = builder.symbol(tok.pos, tok.val);
            advance();
            if (tok.kind == TokenKind.Argument) {
                n.actualArgs = tok.val;
                advance();
            }
        }
        else if (tok.kind == TokenKind.String) {
            n = builder.symbol(tok.pos, tok.val, true);
            advance();
        }
        else if (tok.kind == TokenKind.Code) {
            n = builder.code(tok.pos, tok.val);
            advance();
        }
        else if (tok.kind == TokenKind.Percentif) {
            advance();
            if (expect(TokenKind.Code))
                goto _error;
            n = builder.code(tok.pos, tok.val); n.codeType = CodeType.Condition;
            advance();
        }
        if (last is null) node.inner = last = n;
                                           else last.next = n, last = n;
    }
    if (last !is null) last.back = node;
    return;
_error:
    while (tok.kind != TokenKind._eoi && !tok.kind.among(TokenKind.RightParenthesis, TokenKind.RightParenthesisStar, TokenKind.RightParenthesisPlus, TokenKind.RightParenthesisQuestion, TokenKind.Semi, TokenKind.Pipe))
        advance();
}

void parseGroup(out Node node) {
    if (expect(TokenKind.LeftParenthesis))
        goto _error;
    node = builder.group(tok.pos, Cardinality.One);
    advance();
    parseRhs(node.link);
    node.link.back = node;
    if (tok.kind == TokenKind.RightParenthesis) {
        advance();
    }
    else if (tok.kind == TokenKind.RightParenthesisQuestion) {
        node.cardinality = Cardinality.ZeroOrOne;
        advance();
    }
    else if (tok.kind == TokenKind.RightParenthesisStar) {
        node.cardinality = Cardinality.ZeroOrMore;
        advance();
    }
    else if (tok.kind == TokenKind.RightParenthesisPlus) {
        node.cardinality = Cardinality.OneOrMore;
        advance();
    }
    return;
_error:
    while (tok.kind != TokenKind._eoi && !tok.kind.among(TokenKind.Percentif, TokenKind.LeftParenthesis, TokenKind.RightParenthesis, TokenKind.RightParenthesisStar, TokenKind.RightParenthesisPlus, TokenKind.RightParenthesisQuestion, TokenKind.Semi, TokenKind.Pipe, TokenKind.Code, TokenKind.Identifier, TokenKind.String))
        advance();
}
